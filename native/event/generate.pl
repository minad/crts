#!/usr/bin/perl -w
use strict;
use File::Slurper qw(read_text write_text);

my $generated = 'Generated by generate.pl from defs.in';
my $defs = read_text "runtime/native/event/defs.in";
my $types = "";
my %type = ();
my $enum_names = "";

while ($defs =~ /CHI_NEWTYPE\((\w+),\s*(\w+)\)/gs) {
    $types .= "typedef $2 Chi$1;\n\n";
    $type{"Chi$1"} = ['newtype', $1, $2];
}

while ($defs =~ /typedef\s+enum\s+.*?\{(.*?)\}\s*(\w+);/gs) {
    my $lines = $1;
    my $name = $2;
    $lines =~ s/\s//g;
    my @enums = split ',', $lines;
    $type{$name} = ['enum', $name];
    $types .= "typedef uint32_t $name;\n\n";
    $enum_names .= " \\\n  " if $enum_names ne "";
    $enum_names .= "static const char* const enum${name}[] = {";
    foreach (@enums) {
        if ($_ !~ /^_/) {
            s/^CHI_//;
            $enum_names .= "\"$_\",";
        }
    }
    $enum_names .= "};"
}

while ($defs =~ /typedef\s+struct\s+.*?\{(.*?)\}\s*(\w+);/gs) {
    my $lines = $1;
    my $name = $2;
    $types .= "$&\n\n";
    $lines =~ s/\A\s+|\s+\Z//g;
    my @fields = ();
    foreach my $s (split /\n/, $lines) {
        $s =~ s/\s+/ /g;
        $s =~ s/;//g;
        my @type = split ' ', $s;
        die ("Invalid field type $s\n") if ($#type != 1);
        my ($type, $field) = @type;
        next if ($field =~ /^_/);
        if ($type =~ /ChiStringRef|size_t|uintptr_t|u?int\d+_t|char\*|bool/) {
            push @fields, [$field, [$type]];
        } elsif ($type{$type}) {
            push @fields, [$field, $type{$type}];
        } elsif ($type =~ /^(\w+)\*$/ && $type{$1}) {
            push @fields, [$field, ['ptr', $type{$1}]];
        } else {
            die "Invalid type $type\n";
        }
    }
    $type{$name} = ['struct', \@fields];
}

while ($defs =~ /typedef\s+(\w+)\s+(\w+);/gs) {
    $type{$2} = $type{$1};
}

sub writeField {
    my($indent, $type, $ptr) = @_;
    my $t = $$type[0];
    my $ind = ' ' x $indent;
    if ($t eq 'struct') {
        my @fields = @{$$type[1]};
        my $ret = "";
        my $i = 0;
        foreach my $f (@fields) {
            ++$i;
            if ($$f[1][0] eq 'ptr' && $$f[1][1][0] eq 'struct') {
                $ret .= "${ind}XBLOCK_BEGIN(\"$$f[0]\");\n";
                $ret .= writeField($indent + 4, $$f[1], "$ptr$$f[0]");
                $ret .= "${ind}XBLOCK_END(\"$$f[0]\");\n";
            } elsif ($$f[1][0] eq 'struct') {
                my @subfields = @{$$f[1][1]};
                if ($#subfields > 0) {
                    $ret .= "${ind}XBLOCK_BEGIN(\"$$f[0]\");\n";
                    $ret .= writeField($indent + 4, $$f[1], "$ptr$$f[0].");
                    $ret .= "${ind}XBLOCK_END(\"$$f[0]\");\n";
                } else {
                    $ret .= "${ind}XFIELD(\"$$f[0]\", " . writeField(0, $subfields[0][1], "$ptr$$f[0].$subfields[0][0]") . ");\n";
                }
            } else {
                $ret .= "${ind}XFIELD(\"$$f[0]\", " . writeField(0, $$f[1], "$ptr$$f[0]") . ");\n";
            }
        }
        return $ret;
    }
    return "${ind}XNUM(CHI_UN($$type[1], $ptr))" if ($t eq "newtype");
    return "${ind}XENUM($$type[1], $ptr)" if ($t eq "enum");
    return "${ind}XSNUM($ptr)" if ($t =~ /^(int\d+_t)$/);
    return "${ind}XNUM($ptr)" if ($t =~ /^(size_t|uintptr_t|uint\d+_t|bool)$/);
    return "${ind}XSTR($ptr)" if ($t eq 'ChiStringRef');
    return "${ind}XSTR(chiStringRef($ptr))" if ($t eq 'char*');
    die "Invalid type $t";
}

sub ctfField {
    my($type, $name, $ptr) = @_;
    my $t = $$type[0];
    return ctfField($$type[1], $name, $ptr) if ($t eq 'ptr');
    if ($t eq 'struct') {
        my @fields = @{$$type[1]};
        if ($#fields == 0 && ${$fields[0][1]}[0] eq 'ptr') {
            return ctfField($fields[0][1], $name, "$ptr$fields[0][0]->");
        }
        if ($#fields == 0 && ${$fields[0][1]}[0] eq 'struct') {
            return ctfField($fields[0][1], $name, "$ptr$fields[0][0].");
        }
        if ($#fields == 0 && $name ne "" && $ptr ne "") {
            return ctfField($fields[0][1], $name, "$ptr$fields[0][0]") . "\n";
        }
        my $ret = "";
        my $i = 0;
        foreach my $f (@fields) {
            ++$i;
            my $n = $name eq "" ? $$f[0] : "${name}_$$f[0]";
            if ($$f[1][0] eq 'ptr' && $$f[1][1][0] eq 'struct') {
                $ret .= ctfField($$f[1], $n, "$ptr$$f[0]->");
            } elsif ($$f[1][0] eq 'struct') {
                $ret .= ctfField($$f[1], $n, "$ptr$$f[0].");
            } else {
                $ret .= ctfField($$f[1], $n, "$ptr$$f[0]") . "\n";
            }
        }
        return $ret;
    }
    return "        ctf_integer($$type[2], $name, CHI_UN($$type[1], $ptr))" if ($t eq "newtype");
    return "        ctf_integer_hex($t, $name, $ptr)" if ($t eq "uintptr_t");
    return "        ctf_integer($t, $name, $ptr)" if ($t =~ /^(size_t|u?int\d+_t|bool)$/);
    return "        ctf_integer(uint32_t, $name, $ptr)" if ($t =~ /^(enum)$/);
    return "        ctf_string($name, $ptr)" if ($t eq 'char*');
    return "        ctf_sequence_text(uint8_t, $name, $ptr.bytes, uint32_t, $ptr.size)" if ($t eq 'ChiStringRef');
    die "Invalid type $t";
}

my $fns = "";
foreach my $name (sort(keys %type)) {
    if ($name =~ /^ChiEvent(\w+)$/) {
        my $field = writeField 4, $type{$name}, "d->";
        $fns .= "static bool CHI_CAT(XFORMAT, Payload$1)(Log* log, const $name* d, XSTATE xstate) {
${field}    return true;
}

";
    }
}

my $mainFn = "";
while ($defs =~ /(DURATION|INSTANT)\s+(\w+)\s+(\w+)\s+(\w+)\s*/g) {
    my $cls = $1;
    my $name = $2;
    my $payload = $4;
    if ($cls eq "DURATION") {
        $mainFn .= "    case CHI_EVENT_${name}_BEGIN: break;\n";
        $mainFn .= "    case CHI_EVENT_${name}_END: ";
        $mainFn .= "CHI_CAT(XFORMAT, Payload$payload)(log, e->data.${name}_END, xstate);" if $payload ne "0";
        $mainFn .= "break;\n";
    } else {
        $mainFn .= "    case CHI_EVENT_$name: ";
        $mainFn .= "CHI_CAT(XFORMAT, Payload$payload)(log, e->data.$name, xstate);" if $payload ne "0";
        $mainFn .= "break;\n";
    }
}

write_text "runtime/native/event/writer.h",
        qq(// $generated

${fns}static bool CHI_CAT(XFORMAT, Payload)(Log* log, const Event* e, XSTATE xstate) {
    switch (e->type) {
$mainFn    default: break;
    }
    return true;
}

static bool CHI_CAT(XFORMAT, Event)(Log* log, const Event* e) {
    XINIT;
    XEVENT_BEGIN(e->type);
    XFIELD("ts", XNUM(CHI_UN(Nanos, e->time)));
    if (eventDesc[e->type].cls == CLASS_END)
        XFIELD("dur", XNUM(CHI_UN(Nanos, e->dur)));
    if (eventDesc[e->type].ctx != CTX_RUNTIME)
        XFIELD("wid", XNUM(e->wid));
    if (eventDesc[e->type].ctx == CTX_THREAD)
        XFIELD("tid", XNUM(chiToUnboxed(chiToThread(e->thread)->tid)));
    if (e->data.ANY)
        CHI_CAT(XFORMAT, Payload)(log, e, xstate);
    XEVENT_END(e->type);
    return true;
}

#include "undef.h"
);

my $lttng = "";
while ($defs =~ /(DURATION|INSTANT)\s+(\w+)\s+(\w+)\s+(\w*)\s*/g) {
    my $cls = $1;
    my $name = $2;
    my $ctx = $3;
    my $payload = $4;

    my $end = "";
    if ($cls eq "DURATION") {
        $end = "_END";
        $lttng .= "TRACEPOINT_EVENT(
    chili,
    ${name}_BEGIN,
";
        $lttng .= "    TP_ARGS(";
        if ($ctx eq "THREAD" || $ctx eq "PROCESSOR") {
            $lttng .= "const ChiProcessor*, proc";
        } elsif ($ctx eq "WORKER") {
            $lttng .= "const ChiWorker*, worker";
        } else {
            $lttng .= "const ChiRuntime*, rt";
        }
        $lttng .= "),\n    TP_FIELDS(\n";
        if ($ctx eq "THREAD") {
            $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)proc->rt)\n";
            $lttng .= "        ctf_integer(uint32_t, wid, proc->worker->wid)\n";
            $lttng .= "        ctf_integer(uint64_t, tid, chiToUnboxed(chiToThread(proc->thread)->tid))\n";
        } elsif ($ctx eq "PROCESSOR") {
            $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)proc->rt)\n";
            $lttng .= "        ctf_integer(uint32_t, wid, proc->worker->wid)\n";
        } elsif ($ctx eq "WORKER") {
            $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)worker->rt)\n";
            $lttng .= "        ctf_integer(uint32_t, wid, worker->wid)\n";
        } else {
            $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)rt)\n";
        }
        $lttng .= "    )\n)\n\n";
    }

    $lttng .= "TRACEPOINT_EVENT(
    chili,
    $name$end,
";

    $lttng .= "    TP_ARGS(";
    if ($ctx eq "THREAD" || $ctx eq "PROCESSOR") {
        $lttng .= "const ChiProcessor*, proc";
    } elsif ($ctx eq "WORKER") {
        $lttng .= "const ChiWorker*, worker";
    } else {
        $lttng .= "const ChiRuntime*, rt";
    }
    if ($payload ne "0") {
        $lttng .= ", ";
        $lttng .= "const ChiEvent$payload*, d";
    }

    $lttng .= "),\n    TP_FIELDS(\n";
    if ($ctx eq "THREAD") {
        $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)proc->rt)\n";
        $lttng .= "        ctf_integer(uint32_t, wid, proc->worker->wid)\n";
        $lttng .= "        ctf_integer(uint64_t, tid, chiToUnboxed(chiToThread(proc->thread)->tid))\n";
    } elsif ($ctx eq "PROCESSOR") {
        $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)proc->rt)\n";
        $lttng .= "        ctf_integer(uint32_t, wid, proc->worker->wid)\n";
    } elsif ($ctx eq "WORKER") {
        $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)worker->rt)\n";
        $lttng .= "        ctf_integer(uint32_t, wid, worker->wid)\n";
    } else {
        $lttng .= "        ctf_integer_hex(uintptr_t, rt, (uintptr_t)rt)\n";
    }
    $lttng .= ctfField($type{"ChiEvent$payload"}, "", "d->")if ($payload ne "0");

    $lttng .= "    )\n)\n\n";
}

write_text "runtime/native/event/lttng.h",
        qq(// $generated

#undef TRACEPOINT_PROVIDER
#define TRACEPOINT_PROVIDER chili

#undef TRACEPOINT_INCLUDE
#define TRACEPOINT_INCLUDE "../event/lttng.h"

#if !defined(_CHI_EVENT_LTTNG_H) || defined(TRACEPOINT_HEADER_MULTI_READ)
#define _CHI_EVENT_LTTNG_H

#include "../processor.h"
#include <chili/object/thread.h>
#include <lttng/tracepoint.h>

${lttng}#endif

#include <lttng/tracepoint-event.h>
);

my $dtrace = "";
while ($defs =~ /(DURATION|INSTANT)\s+(\w+)\s+(\w+)\s+(\w*)\s*/g) {
    my $cls = $1;
    my $name = lc $2;
    my $ctx = $3;
    my $payload = $4;
    $name =~ s/_/__/g;
    if ($ctx eq "THREAD" || $ctx eq "PROCESSOR") {
        $ctx = "ChiProcessor*";
    } elsif ($ctx eq "WORKER") {
        $ctx = "ChiWorker*";
    } else {
        $ctx = "ChiRuntime*";
    }
    $payload = $payload eq "0" ? "" : ", ChiEvent$payload*";
    if ($cls eq "DURATION") {
        $dtrace .= "  probe ${name}__begin($ctx);\n  probe ${name}__end($ctx$payload);\n";
    } else {
        $dtrace .= "  probe $name($ctx$payload);\n";
    }
}

write_text "runtime/native/event/dtrace.d",
        "/* $generated */

typedef struct {
    uint32_t size;
    uint8_t* bytes;
} ChiStringRef;

typedef struct ChiRuntime_   ChiRuntime;
typedef struct ChiWorker_    ChiWorker;
typedef struct ChiProcessor_ ChiProcessor;

${types}provider chili {
$dtrace};
";

my $hash = "";
my $const = "";
my $exp = "";
my $exp2 = "  \$F_e\n  \$F_ts\n  \$F_dur\n  \$F_dur_wid\n  \$F_dur_tid\n  \$F_instant_wid\n  \$F_instant_tid\n";
my $fields = "our \$F_e = 0;\nour \$F_ts = 1;\nour \$F_dur = 2;\nour \$F_dur_wid = 3;\nour \$F_dur_tid = 4;\nour \$F_instant_wid = 2;\nour \$F_instant_tid = 3;\n";
for (my $id = 0; $defs =~ /(DURATION|INSTANT)\s+(\w+)\s+(\w+)\s+(\w*)\s*/g; ++$id) {
    my $class = $1;
    my $ev = $2;
    my $ctx = $3;
    my $payload = $4;
    ++$id if $class eq "DURATION";
    $hash .= qq(@{[$id > 0 ? ",\n  " : '']}$2 => $id);
    $exp .= "  \$E_$2\n";
    $const .= "our \$E_$2 = $id;\n";
    if ($payload ne "0") {
        my $tmp = ctfField($type{"ChiEvent$payload"}, $ev, "");
        my $j = 2;
        ++$j if ($class eq "DURATION");
        ++$j if ($ctx ne "RUNTIME");
        ++$j if ($ctx eq "THREAD");
        while ($tmp =~ /(${ev}_\w+)/g) {
            $exp2 .= "  \$F_$1\n";
            $fields .= "our \$F_$1 = $j;\n";
            ++$j;
        }
    }
}

write_text "runtime/native/event/names.pm",
        "# $generated
package event::names;
use strict;
our \@ISA = qw(Exporter);
our \@EXPORT = qw(
  \%E
$exp$exp2);
our \%E = (
  $hash
);
${const}${fields}1;
";

$const = "";
$fields = "e 0\nts 1\ndur 2\ndur_wid 3\ndur_tid 4\ninstant_wid 2\ninstant_tid 3\n";
for (my $id = 0; $defs =~ /(DURATION|INSTANT)\s+(\w+)\s+(\w+)\s+(\w*)\s*/g; ++$id) {
    my $class = $1;
    my $ev = $2;
    my $ctx = $3;
    my $payload = $4;
    ++$id if $class eq "DURATION";
    $const .= "$2 $id\n";
    if ($payload ne "0") {
        my $tmp = ctfField($type{"ChiEvent$payload"}, $ev, "");
        my $j = 2;
        ++$j if ($class eq "DURATION");
        ++$j if ($ctx ne "RUNTIME");
        ++$j if ($ctx eq "THREAD");
        while ($tmp =~ /(${ev}_\w+)/g) {
            $fields .= "$1 $j\n";
            ++$j;
        }
    }
}

write_text "runtime/native/event/defs.flat", "# $generated\n# Events\n$const\n# Fields\n$fields";

my $table = "";
while ($defs =~ /(DURATION|INSTANT)\s+(\w+)\s+(\w+)\s+(\w*)\s*([^\s]*)\s*"(.*?)"/g) {
    my $class = $1;
    my $ev = $2;
    my $ctx = $3;
    my $payload = $4;
    my $desc = $6;
    if ($class eq "DURATION") {
        $class = "Duration";
    } else {
        $class = "Instant";
    }
    if ($payload ne "0") {
        $payload = "ChiEvent$payload";
    }
    $ctx = ucfirst (lc $ctx);
    $payload = "" if ($payload eq "0");
    $table .= "|$class|$ev|$ctx|$payload|$desc\n";
}

write_text "runtime/native/event/table.adoc",
        qq(// $generated

|===
|Class|Event|Context|Payload|Description

$table|===
);

my $enum = "";
my $contexttypes = "";
my $union = "";
my $names = "";
my $maxlen = 0;
my $desc = "";
my $dur_stats_enum = "";
my $instant_stats_enum = "";
my $count = 0;

while ($defs =~ /(DURATION|INSTANT)\s+(\w+)\s+(\w+)\s+(\w+)\s+([^\s]+)/g) {
    my $cls = $1;
    my $name = $2;
    my $ctx = $3;
    my $payload = $4;
    my $stats = $5;

    $maxlen = length($name) if (length($name) > $maxlen);
    $desc .= ", \\\n  " if ($desc);
    $names .= ", \\\n  " if ($names);
    if ($cls eq "DURATION") {
        $desc .= "{ .payload = @{[$payload ne \"0\" ? 1 : 0]}, .stats = @{[$stats ne \"0\" ? \"DSTATS_$name\" : 'DSTATS_NONE']}, .ctx = CTX_$ctx, .cls = CLASS_BEGIN }, \\\n  ";
        $desc .= "{ .payload = @{[$payload ne \"0\" ? 1 : 0]}, .stats = @{[$stats ne \"0\" ? \"DSTATS_$name\" : 'DSTATS_NONE']}, .ctx = CTX_$ctx, .cls = CLASS_END }";
        $names .= "\"${name}\", \\\n  \"${name}\"";
        $enum .= "  CHI_EVENT_${name}_BEGIN,\n  CHI_EVENT_${name}_END,\n";
        $count += 2;

        if ($stats ne "0") {
            $dur_stats_enum .= ", \\\n  " if $dur_stats_enum;
            $dur_stats_enum .= "DSTATS_$name";
            if ($stats ne "1") {
                $dur_stats_enum .= ", _END_STATS_$name = DSTATS_$name + $stats - 1";
            }
        }
    } else {
        $desc .= "{ .payload = @{[$payload ne \"0\" ? 1 : 0]}, .stats = @{[$stats ne \"0\" ? \"ISTATS_$name\" : 'ISTATS_NONE']}, .ctx = CTX_$ctx, .cls = CLASS_INSTANT }";
        $names .= "\"$name\"";
        $enum .= "  CHI_EVENT_$name,\n";
        $count += 1;

        if ($stats ne "0") {
            $instant_stats_enum .= ", \\\n  " if $instant_stats_enum;
            $instant_stats_enum .= "ISTATS_$name";
            if ($stats ne "1") {
                $instant_stats_enum .= ", _END_ISTATS_$name = ISTATS_$name + $stats - 1";
            }
        }
    }

    if ($payload ne "0") {
        $union .= $cls eq "DURATION"
            ? "  const ChiEvent$payload* ${name}_END;\n"
            : "  const ChiEvent$payload* ${name};\n";
    }

    if ($ctx eq "RUNTIME") {
        if ($cls eq "DURATION") {
            $contexttypes .= "typedef ChiRuntime _CHI_EVENT_CTX_${name}_BEGIN;\n";
            $contexttypes .= "typedef ChiRuntime _CHI_EVENT_CTX_${name}_END;\n";
        } else {
            $contexttypes .= "typedef ChiRuntime _CHI_EVENT_CTX_${name};\n";
        }
    } elsif ($ctx eq "WORKER") {
        if ($cls eq "DURATION") {
            $contexttypes .= "typedef ChiWorker _CHI_EVENT_CTX_${name}_BEGIN;\n";
            $contexttypes .= "typedef ChiWorker _CHI_EVENT_CTX_${name}_END;\n";
        } else {
            $contexttypes .= "typedef ChiWorker _CHI_EVENT_CTX_${name};\n";
        }
    } else {
        if ($cls eq "DURATION") {
            $contexttypes .= "typedef ChiProcessor _CHI_EVENT_CTX_${name}_BEGIN;\n";
            $contexttypes .= "typedef ChiProcessor _CHI_EVENT_CTX_${name}_END;\n";
        } else {
            $contexttypes .= "typedef ChiProcessor _CHI_EVENT_CTX_${name};\n";
        }
    }
}

$defs =~ s/\s*#.*//sg;
write_text "runtime/native/event/defs.h",
    qq(// $generated
#pragma once

#include <chili/object/string.h>

typedef struct ChiRuntime_   ChiRuntime;
typedef struct ChiWorker_    ChiWorker;
typedef struct ChiProcessor_ ChiProcessor;

$defs

#define _CHI_EVENT_DESC \\
  const char* const chiEventName[] = { \\
  $names }; \\
  static const struct CHI_PACKED { \\
    bool           payload : 1; \\
    EventClass     cls     : 2; \\
    EventContext   ctx     : 2; \\
    uint8_t        stats   : 8; \\
    uint8_t        _pad    : 3; \\
  } eventDesc[] = { $desc }; \\
  $enum_names

#define _CHI_EVENT_DSTATS \\
  $dur_stats_enum

#define _CHI_EVENT_ISTATS \\
  $instant_stats_enum

enum {
  _CHI_EVENT_COUNT = $count,
  _CHI_EVENT_MAXLEN = $maxlen,
};

typedef enum {
$enum} ChiEvent;

typedef union {
    const void* ANY;
$union} ChiEventData;

$contexttypes);
