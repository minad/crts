-- Generated by generate.pl from insn.defs and priminsn.defs

firstPrim :: Int
firstPrim = 92

insn_idx1 :: HasCallStack => Imm i0 => Reg -> Reg -> i0 -> Emit ()
insn_idx1 res var i0 = do
  u16 (0 :: Word16)
  reg8 res
  reg8 var
  u8 i0

insn_idx2 :: HasCallStack => Imm i0 => Imm i1 => Reg -> Reg -> i0 -> i1 -> Emit ()
insn_idx2 res var i0 i1 = do
  u16 (1 :: Word16)
  reg8 res
  reg8 var
  u8 i0
  u8 i1

insn_idxl1 :: HasCallStack => Imm i0 => Reg -> Reg -> i0 -> Emit ()
insn_idxl1 res var i0 = do
  u16 (2 :: Word16)
  reg16 res
  reg16 var
  u16 i0

insn_idxl2 :: HasCallStack => Imm i0 => Imm i1 => Reg -> Reg -> i0 -> i1 -> Emit ()
insn_idxl2 res var i0 i1 = do
  u16 (3 :: Word16)
  reg16 res
  reg16 var
  u16 i0
  u16 i1

insn_fset :: HasCallStack => Imm i => Reg -> i -> Reg -> Emit ()
insn_fset var i field = do
  u16 (4 :: Word16)
  reg16 var
  u16 i
  reg16 field

insn_tset :: HasCallStack => Imm i => Reg -> i -> Reg -> Emit ()
insn_tset var i field = do
  u16 (5 :: Word16)
  reg16 var
  u16 i
  reg16 field

insn_int8 :: HasCallStack => Integral val => Reg -> val -> Emit ()
insn_int8 res val = do
  u16 (6 :: Word16)
  reg8 res
  i8 val

insn_int32 :: HasCallStack => Integral val => Reg -> val -> Emit ()
insn_int32 res val = do
  u16 (7 :: Word16)
  reg16 res
  i32 val

insn_int64 :: HasCallStack => Integral val => Reg -> val -> Emit ()
insn_int64 res val = do
  u16 (8 :: Word16)
  reg16 res
  i64 val

insn_uint8 :: HasCallStack => Imm val => Reg -> val -> Emit ()
insn_uint8 res val = do
  u16 (9 :: Word16)
  reg8 res
  u8 val

insn_uint32 :: HasCallStack => Imm val => Reg -> val -> Emit ()
insn_uint32 res val = do
  u16 (10 :: Word16)
  reg16 res
  u32 val

insn_uint64 :: HasCallStack => Imm val => Reg -> val -> Emit ()
insn_uint64 res val = do
  u16 (11 :: Word16)
  reg16 res
  u64 val

insn_float32 :: HasCallStack => Reg -> Float -> Emit ()
insn_float32 res val = do
  u16 (12 :: Word16)
  reg16 res
  u32 (castFloatToWord32 val)

insn_float64 :: HasCallStack => Reg -> Double -> Emit ()
insn_float64 res val = do
  u16 (13 :: Word16)
  reg16 res
  u64 (castDoubleToWord64 val)

insn_string :: HasCallStack => ConvertString bref ByteString => Reg -> bref -> Emit ()
insn_string res bref = do
  u16 (14 :: Word16)
  reg16 res
  bytesref bref

insn_buffer :: HasCallStack => ConvertString bref ByteString => Reg -> bref -> Emit ()
insn_buffer res bref = do
  u16 (15 :: Word16)
  reg16 res
  bytesref bref

insn_xint :: HasCallStack => ConvertString bref ByteString => Reg -> bref -> Emit ()
insn_xint res bref = do
  u16 (16 :: Word16)
  reg16 res
  bytesref bref

insn_xintn :: HasCallStack => ConvertString bref ByteString => Reg -> bref -> Emit ()
insn_xintn res bref = do
  u16 (17 :: Word16)
  reg16 res
  bytesref bref

insn_xint8 :: HasCallStack => Integral val => Reg -> val -> Emit ()
insn_xint8 res val = do
  u16 (18 :: Word16)
  reg8 res
  i8 val

insn_xint64 :: HasCallStack => Integral val => Reg -> val -> Emit ()
insn_xint64 res val = do
  u16 (19 :: Word16)
  reg16 res
  i64 val

insn_movc2 :: HasCallStack => Reg -> Reg -> Emit ()
insn_movc2 res src = do
  u16 (20 :: Word16)
  reg8 res
  reg8 src

insn_movc3 :: HasCallStack => Reg -> Reg -> Emit ()
insn_movc3 res src = do
  u16 (21 :: Word16)
  reg8 res
  reg8 src

insn_movc4 :: HasCallStack => Reg -> Reg -> Emit ()
insn_movc4 res src = do
  u16 (22 :: Word16)
  reg8 res
  reg8 src

insn_movcl2 :: HasCallStack => Reg -> Reg -> Emit ()
insn_movcl2 res src = do
  u16 (23 :: Word16)
  reg16 res
  reg16 src

insn_movcl3 :: HasCallStack => Reg -> Reg -> Emit ()
insn_movcl3 res src = do
  u16 (24 :: Word16)
  reg16 res
  reg16 src

insn_movcl4 :: HasCallStack => Reg -> Reg -> Emit ()
insn_movcl4 res src = do
  u16 (25 :: Word16)
  reg16 res
  reg16 src

insn_mov1 :: HasCallStack => Reg -> Reg -> Emit ()
insn_mov1 res src0 = do
  u16 (26 :: Word16)
  reg8 res
  reg8 src0

insn_mov2 :: HasCallStack => Reg -> Reg -> Reg -> Emit ()
insn_mov2 res src0 src1 = do
  u16 (27 :: Word16)
  reg8 res
  reg8 src0
  reg8 src1

insn_mov3 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Emit ()
insn_mov3 res src0 src1 src2 = do
  u16 (28 :: Word16)
  reg8 res
  reg8 src0
  reg8 src1
  reg8 src2

insn_mov4 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Reg -> Emit ()
insn_mov4 res src0 src1 src2 src3 = do
  u16 (29 :: Word16)
  reg8 res
  reg8 src0
  reg8 src1
  reg8 src2
  reg8 src3

insn_movl1 :: HasCallStack => Reg -> Reg -> Emit ()
insn_movl1 res src0 = do
  u16 (30 :: Word16)
  reg16 res
  reg16 src0

insn_movl2 :: HasCallStack => Reg -> Reg -> Reg -> Emit ()
insn_movl2 res src0 src1 = do
  u16 (31 :: Word16)
  reg16 res
  reg16 src0
  reg16 src1

insn_thk :: HasCallStack => Imm nclos => Reg -> TopName -> nclos -> Emit ()
insn_thk res fnref nclos = do
  u16 (32 :: Word16)
  reg16 res
  ref (FnRef fnref)
  u16 nclos

insn_thk0 :: HasCallStack => Reg -> TopName -> Emit ()
insn_thk0 res fnref = do
  u16 (33 :: Word16)
  reg8 res
  ref (FnRef fnref)

insn_thk1 :: HasCallStack => Reg -> Reg -> TopName -> Emit ()
insn_thk1 res c0 fnref = do
  u16 (34 :: Word16)
  reg8 res
  reg8 c0
  ref (FnRef fnref)

insn_thk2 :: HasCallStack => Reg -> Reg -> Reg -> TopName -> Emit ()
insn_thk2 res c0 c1 fnref = do
  u16 (35 :: Word16)
  reg8 res
  reg8 c0
  reg8 c1
  ref (FnRef fnref)

insn_thk3 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> TopName -> Emit ()
insn_thk3 res c0 c1 c2 fnref = do
  u16 (36 :: Word16)
  reg8 res
  reg8 c0
  reg8 c1
  reg8 c2
  ref (FnRef fnref)

insn_thk4 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Reg -> TopName -> Emit ()
insn_thk4 res c0 c1 c2 c3 fnref = do
  u16 (37 :: Word16)
  reg8 res
  reg8 c0
  reg8 c1
  reg8 c2
  reg8 c3
  ref (FnRef fnref)

insn_fn :: HasCallStack => Imm arity => Imm nclos => Reg -> TopName -> arity -> nclos -> Emit ()
insn_fn res fnref arity nclos = do
  u16 (38 :: Word16)
  reg16 res
  ref (FnRef fnref)
  u8 arity
  u16 nclos

insn_fn0 :: HasCallStack => Imm arity => Reg -> arity -> TopName -> Emit ()
insn_fn0 res arity fnref = do
  u16 (39 :: Word16)
  reg8 res
  u8 arity
  ref (FnRef fnref)

insn_fn1 :: HasCallStack => Imm arity => Reg -> arity -> Reg -> TopName -> Emit ()
insn_fn1 res arity c0 fnref = do
  u16 (40 :: Word16)
  reg8 res
  u8 arity
  reg8 c0
  ref (FnRef fnref)

insn_fn2 :: HasCallStack => Imm arity => Reg -> arity -> Reg -> Reg -> TopName -> Emit ()
insn_fn2 res arity c0 c1 fnref = do
  u16 (41 :: Word16)
  reg8 res
  u8 arity
  reg8 c0
  reg8 c1
  ref (FnRef fnref)

insn_fn3 :: HasCallStack => Imm arity => Reg -> arity -> Reg -> Reg -> Reg -> TopName -> Emit ()
insn_fn3 res arity c0 c1 c2 fnref = do
  u16 (42 :: Word16)
  reg8 res
  u8 arity
  reg8 c0
  reg8 c1
  reg8 c2
  ref (FnRef fnref)

insn_fn4 :: HasCallStack => Imm arity => Reg -> arity -> Reg -> Reg -> Reg -> Reg -> TopName -> Emit ()
insn_fn4 res arity c0 c1 c2 c3 fnref = do
  u16 (43 :: Word16)
  reg8 res
  u8 arity
  reg8 c0
  reg8 c1
  reg8 c2
  reg8 c3
  ref (FnRef fnref)

insn_con :: HasCallStack => Imm tag => Imm nargs => Reg -> tag -> nargs -> Emit ()
insn_con res tag nargs = do
  u16 (44 :: Word16)
  reg16 res
  u16 tag
  u16 nargs

insn_con0 :: HasCallStack => Imm tag => Reg -> tag -> Emit ()
insn_con0 res tag = do
  u16 (45 :: Word16)
  reg8 res
  u8 tag

insn_conl0 :: HasCallStack => Imm tag => Reg -> tag -> Emit ()
insn_conl0 res tag = do
  u16 (46 :: Word16)
  reg16 res
  u16 tag

insn_con1 :: HasCallStack => Imm tag => Reg -> tag -> Reg -> Emit ()
insn_con1 res tag a0 = do
  u16 (47 :: Word16)
  reg8 res
  u8 tag
  reg8 a0

insn_con2 :: HasCallStack => Imm tag => Reg -> tag -> Reg -> Reg -> Emit ()
insn_con2 res tag a0 a1 = do
  u16 (48 :: Word16)
  reg8 res
  u8 tag
  reg8 a0
  reg8 a1

insn_con3 :: HasCallStack => Imm tag => Reg -> tag -> Reg -> Reg -> Reg -> Emit ()
insn_con3 res tag a0 a1 a2 = do
  u16 (49 :: Word16)
  reg8 res
  u8 tag
  reg8 a0
  reg8 a1
  reg8 a2

insn_con4 :: HasCallStack => Imm tag => Reg -> tag -> Reg -> Reg -> Reg -> Reg -> Emit ()
insn_con4 res tag a0 a1 a2 a3 = do
  u16 (50 :: Word16)
  reg8 res
  u8 tag
  reg8 a0
  reg8 a1
  reg8 a2
  reg8 a3

insn_casetbl :: HasCallStack => Imm lo => Imm hi => Reg -> lo -> hi -> Emit ()
insn_casetbl scrut lo hi = do
  u16 (51 :: Word16)
  reg16 scrut
  u32 lo
  u32 hi

insn_case :: HasCallStack => Imm nalts => Reg -> nalts -> Emit ()
insn_case scrut nalts = do
  u16 (52 :: Word16)
  reg16 scrut
  u16 nalts

insn_cont :: HasCallStack => Imm off => Reg -> off -> Emit ()
insn_cont top off = do
  u16 (53 :: Word16)
  reg8 top
  u8 off

insn_contl :: HasCallStack => Imm off => Reg -> off -> Emit ()
insn_contl top off = do
  u16 (54 :: Word16)
  reg16 top
  u32 off

insn_ret :: HasCallStack => Reg -> Emit ()
insn_ret var = do
  u16 (55 :: Word16)
  reg8 var

insn_retl :: HasCallStack => Reg -> Emit ()
insn_retl var = do
  u16 (56 :: Word16)
  reg16 var

insn_retif :: HasCallStack => Reg -> Reg -> Emit ()
insn_retif scrut var = do
  u16 (57 :: Word16)
  reg8 scrut
  reg8 var

insn_retifn :: HasCallStack => Reg -> Reg -> Emit ()
insn_retifn scrut var = do
  u16 (58 :: Word16)
  reg8 scrut
  reg8 var

insn_if :: HasCallStack => Imm off => Reg -> off -> Emit ()
insn_if scrut off = do
  u16 (59 :: Word16)
  reg8 scrut
  u8 off

insn_ifl :: HasCallStack => Imm off => Reg -> off -> Emit ()
insn_ifl scrut off = do
  u16 (60 :: Word16)
  reg16 scrut
  u32 off

insn_jmp :: HasCallStack => Reg -> TopName -> Emit ()
insn_jmp fn fnref = do
  u16 (61 :: Word16)
  reg16 fn
  ref (FnRef fnref)

insn_jmp1 :: HasCallStack => Reg -> Reg -> TopName -> Emit ()
insn_jmp1 fn a0 fnref = do
  u16 (62 :: Word16)
  reg8 fn
  reg8 a0
  ref (FnRef fnref)

insn_jmp2 :: HasCallStack => Reg -> Reg -> Reg -> TopName -> Emit ()
insn_jmp2 fn a0 a1 fnref = do
  u16 (63 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1
  ref (FnRef fnref)

insn_jmp3 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> TopName -> Emit ()
insn_jmp3 fn a0 a1 a2 fnref = do
  u16 (64 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1
  reg8 a2
  ref (FnRef fnref)

insn_jmp4 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Reg -> TopName -> Emit ()
insn_jmp4 fn a0 a1 a2 a3 fnref = do
  u16 (65 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1
  reg8 a2
  reg8 a3
  ref (FnRef fnref)

insn_jmp5 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Reg -> Reg -> TopName -> Emit ()
insn_jmp5 fn a0 a1 a2 a3 a4 fnref = do
  u16 (66 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1
  reg8 a2
  reg8 a3
  reg8 a4
  ref (FnRef fnref)

insn_app :: HasCallStack => Imm nargs => Reg -> nargs -> Emit ()
insn_app fn nargs = do
  u16 (67 :: Word16)
  reg8 fn
  u8 nargs

insn_appn :: HasCallStack => Imm nargs => Reg -> nargs -> Emit ()
insn_appn fn nargs = do
  u16 (68 :: Word16)
  reg16 fn
  u8 nargs

insn_app1 :: HasCallStack => Reg -> Reg -> Emit ()
insn_app1 fn a0 = do
  u16 (69 :: Word16)
  reg8 fn
  reg8 a0

insn_app2 :: HasCallStack => Reg -> Reg -> Reg -> Emit ()
insn_app2 fn a0 a1 = do
  u16 (70 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1

insn_app3 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Emit ()
insn_app3 fn a0 a1 a2 = do
  u16 (71 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1
  reg8 a2

insn_app4 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Reg -> Emit ()
insn_app4 fn a0 a1 a2 a3 = do
  u16 (72 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1
  reg8 a2
  reg8 a3

insn_app5 :: HasCallStack => Reg -> Reg -> Reg -> Reg -> Reg -> Reg -> Emit ()
insn_app5 fn a0 a1 a2 a3 a4 = do
  u16 (73 :: Word16)
  reg8 fn
  reg8 a0
  reg8 a1
  reg8 a2
  reg8 a3
  reg8 a4

insn_limit :: HasCallStack => Imm lim => lim -> Emit ()
insn_limit lim = do
  u16 (74 :: Word16)
  u8 lim

insn_clos1 :: HasCallStack => Imm nargs => Imm lim => nargs -> lim -> Emit ()
insn_clos1 nargs lim = do
  u16 (75 :: Word16)
  u8 nargs
  u8 lim

insn_clos2 :: HasCallStack => Imm nargs => Imm lim => nargs -> lim -> Emit ()
insn_clos2 nargs lim = do
  u16 (76 :: Word16)
  u8 nargs
  u8 lim

insn_clos3 :: HasCallStack => Imm nargs => Imm lim => nargs -> lim -> Emit ()
insn_clos3 nargs lim = do
  u16 (77 :: Word16)
  u8 nargs
  u8 lim

insn_clos4 :: HasCallStack => Imm nargs => Imm lim => nargs -> lim -> Emit ()
insn_clos4 nargs lim = do
  u16 (78 :: Word16)
  u8 nargs
  u8 lim

insn_clos :: HasCallStack => Imm nargs => Imm lim => Imm size => nargs -> lim -> size -> Emit ()
insn_clos nargs lim size = do
  u16 (79 :: Word16)
  u8 nargs
  u16 lim
  u16 size

insn_enter :: HasCallStack => Imm top => Imm lim => top -> lim -> Emit ()
insn_enter top lim = do
  u16 (80 :: Word16)
  u8 top
  u8 lim

insn_enterl :: HasCallStack => Imm top => Imm lim => top -> lim -> Emit ()
insn_enterl top lim = do
  u16 (81 :: Word16)
  u16 top
  u16 lim

insn_ffiget :: HasCallStack => Reg -> FFI -> Emit ()
insn_ffiget res ffi = do
  u16 (82 :: Word16)
  reg16 res
  ref (FFIRef (ffiNameWithoutHeader ffi))

insn_ffiset :: HasCallStack => Reg -> FFI -> Emit ()
insn_ffiset var ffi = do
  u16 (83 :: Word16)
  reg16 var
  ref (FFIRef (ffiNameWithoutHeader ffi))

insn_ffitail :: HasCallStack => Imm nargs => FFI -> nargs -> Emit ()
insn_ffitail ffi nargs = do
  u16 (84 :: Word16)
  ref (FFIRef (ffiNameWithoutHeader ffi))
  u8 nargs

insn_ffiinl :: HasCallStack => Imm nargs => Reg -> FFI -> nargs -> Emit ()
insn_ffiinl res ffi nargs = do
  u16 (85 :: Word16)
  reg16 res
  ref (FFIRef (ffiNameWithoutHeader ffi))
  u8 nargs

insn_ffiprot :: HasCallStack => Imm nargs => FFI -> nargs -> Emit ()
insn_ffiprot ffi nargs = do
  u16 (86 :: Word16)
  ref (FFIRef (ffiNameWithoutHeader ffi))
  u8 nargs

insn_thread :: HasCallStack => Reg -> Emit ()
insn_thread res = do
  u16 (87 :: Word16)
  reg16 res

insn_proc :: HasCallStack => Reg -> Emit ()
insn_proc res = do
  u16 (88 :: Word16)
  reg16 res

insn_plocal :: HasCallStack => Reg -> Emit ()
insn_plocal res = do
  u16 (89 :: Word16)
  reg16 res

insn_tstate :: HasCallStack => Reg -> Reg -> Emit ()
insn_tstate res thr = do
  u16 (90 :: Word16)
  reg16 res
  reg16 thr

insn_evfilt :: HasCallStack => Reg -> Reg -> Reg -> Emit ()
insn_evfilt res f n = do
  u16 (91 :: Word16)
  reg16 res
  reg16 f
  reg16 n

