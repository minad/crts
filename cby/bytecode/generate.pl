#!/usr/bin/perl -w
use strict;
use File::Slurper qw(read_text write_text);

my $generated_by = "Generated by generate.pl from insn.defs and priminsn.defs";

sub parse_args {
    my($s) = (@_);
    my $args = $s;
    my @args = ();
    for (;;) {
        if ($s =~ /\A([rwuif])(\d+):(\w+)\b\s*/ && (int($2) == 8 || int($2) == 16 || int($2) == 32 || int($2) == 64)) {
            $s = $';
            push @args, [$1, int($2), $3];
        } elsif ($s =~ /\A(strref|bytesref|fnref|ffiref)\b\s*/) {
            $s = $';
            push @args, [$1];
        } elsif ($s =~ /\A(\w+)\[(.*?)\]\(/) {
            $s = $';
            my ($name, $count) = ($1, $2);
            ($s, my @elem) = parse_args($s);
            push @args, ["arr", $name, $count, \@elem];
            last unless $s =~ /\A\)\s*/;
            $s = $';
        } else {
            last;
        }
    }
    return ($s, @args);
}

sub gen_doc_args {
    my @args = @_;
    my $out = "";
    foreach (@args) {
        my @arg = @$_;
        if ($arg[0] =~ /\A[rwuif]\Z/) {
            $out .= " " if $out ne "";
            $out .= "$arg[0]$arg[1]:$arg[2]";
        } elsif ($arg[0] eq "arr") {
            $out .= " " if $out ne "";
            my $elem = gen_doc_args(@{$arg[3]});
            $out .= "$arg[1]\[$arg[2]\]($elem)";
        } elsif ($arg[0] =~ /\A(strref|bytesref|ffiref|fnref)\Z/) {
            $out .= " " if $out ne "";
            $out .= "$arg[0]";
        } else {
            $out .= " " if $out ne "";
            $out .= "$arg[0]:$arg[1]";
        }
    }
    return $out;
}

sub gen_doc {
    my @insn = @_;
    my $out = "|===
|Id|Opcode|Operands|Description

";
    foreach (@insn) {
        my ($id, $opcode, $desc, $args) = @$_;
        $out .= "|$id|$opcode|@{[gen_doc_args @$args]}|$desc\n";
    }
    $out .= "|===\n";
    write_text "bytecode.adoc", $out;
}

sub decode_args {
    my ($deref, @args) = @_;
    my @out = ();
    my @fmt = ();
    while (my $arg = shift(@args)) {
        my @arg = @$arg;
        if ($arg[0] eq "r") {
            push @out, $deref ? "const Chili $arg[2] = REG[FETCH$arg[1]];"
                : "const uint$arg[1]_t $arg[2] = FETCH$arg[1];";
            push @fmt, ["ARGR($arg[2])", "(uint32_t)$arg[2]"];
        } elsif ($arg[0] eq "w") {
            push @out, $deref ? "Chili* const $arg[2] = REG + FETCH$arg[1];"
                : "const uint$arg[1]_t $arg[2] = FETCH$arg[1];";
            push @fmt, ["ARGR($arg[2])", "(uint32_t)$arg[2]"];
        } elsif ($arg[0] eq "i" && $arg[1] == 64) {
            push @out, "const int64_t $arg[2] = (int64_t)FETCH64;";
            push @fmt, ["NAME($arg[2])VAL(\"%jd\")", $arg[2]];
        } elsif ($arg[0] eq "u" && $arg[1] == 64) {
            push @out, "const uint64_t $arg[2] = FETCH64;";
            push @fmt, ["NAME($arg[2])VAL(\"%ju\")", $arg[2]];
        } elsif ($arg[0] eq "i") {
            push @out, "const int$arg[1]_t $arg[2] = (int$arg[1]_t)FETCH$arg[1];";
            push @fmt, ["ARGD($arg[2])", "(int32_t)$arg[2]"];
        } elsif ($arg[0] eq "u") {
            push @out, "const uint$arg[1]_t $arg[2] = FETCH$arg[1];";
            push @fmt, ["ARGU($arg[2])", "(uint32_t)$arg[2]"];
        } elsif ($arg[0] eq "f" && $arg[1] == 32) {
            push @out, "const float $arg[2] = CHI_CAST(FETCH32, float);";
            push @fmt, ["NAME($arg[2])VAL(\"%f\")", "(double)$arg[2]"];
        } elsif ($arg[0] eq "f" && $arg[1] == 64) {
            push @out, "const double $arg[2] = CHI_CAST(FETCH64, double);";
            push @fmt, ["NAME($arg[2])VAL(\"%f\")", $arg[2]];
        } elsif ($arg[0] eq "fnref") {
            push @out, "int32_t _fnref = (int32_t)FETCH32; const CbyCode* fnref = IP + _fnref;";
            push @fmt, [" FNREF ", "FNREF_ARGS"];
        } elsif ($arg[0] eq "strref") {
            push @out, "const ChiStringRef strref = FETCH_STRING;";
            push @fmt, ["\" \"VAL(\"%qS\")", "strref"];
        } elsif ($arg[0] eq "bytesref") {
            push @out, "const ChiStringRef bytesref = FETCH_STRING;";
            push @fmt, ["\" \"VAL(\"%hS\")", "bytesref"];
        } elsif ($arg[0] eq "ffiref") {
            push @out, "int32_t _ffiref = (int32_t)FETCH32; const CbyCode* ffiref = IP + _ffiref;";
            push @fmt, [" FFIREF ", "FFIREF_ARGS"];
        } elsif ($arg[0] eq "arr") {
            unshift @args, \@arg;
            last;
        } else {
            die "Invalid $arg[0]";
        }
    }
    my $out = join "\n", @out;
    return ($out, \@fmt, \@args);
}

sub gen_rewrite_args {
    my ($args) = @_;
    my ($decoded, $fmt, $rest) = decode_args(0, @$args);
    if ($#{$rest} >= 0) {
        my @arg = @{${$rest}[0]};
        if ($arg[0] eq "arr") {
            my $body = gen_rewrite_args($arg[3]);
            $body =~ s/(?!\A)^/    /mg;
            $body =~ s/\n\Z| +$//mg;
            $decoded =~ s/^/    /mg;
            return "{\n$decoded\n    for (uint32_t $arg[1]_count = 0; $arg[1]_count < $arg[2]; ++$arg[1]_count) $body\n}\n";
        } else {
            die $arg[0];
        }
    } else {
        $decoded =~ s/^/    /mg;
        return "{\n$decoded\n}\n";
    }
    return "";
}

sub gen_rewrite {
    my @insn = @_;
    my $out = "// $generated_by\n";
    foreach (@insn) {
        my ($id, $opcode, $desc, $args, $body) = @$_;
        $out .= "case OP_$opcode: " . gen_rewrite_args($args) . "break;\n";
    }
    write_text "rewrite.h", $out;
}

sub gen_interp {
    my @insn = @_;
    my $out = "// $generated_by\nDISPATCH_BEGIN\n";
    foreach (@insn) {
        my ($id, $opcode, $desc, $args, $body) = @$_;
        my ($decoded, $fmt) = decode_args(1, @$args);
        $decoded =~ s/^/    /mg;
        $out .= "OP_BEGIN($opcode)\n$decoded\n${body}OP_END\n";
    }
    $out .= "DISPATCH_END\n";
    write_text "interp.h", $out;
}

sub gen_disasm_args {
    my($prefix, $args) = @_;
    (my $decoded, my $fmt, my $rest) = decode_args(0, @$args);
    $decoded =~ s/^/    /mg;
    my $out = "{\n$prefix$decoded\n";
    my $fmtstr = "";
    my $fmtarg = "";
    foreach (@$fmt) {
        my ($fs, $fa) = @$_;
        $fmtstr .= "$fs";
        $fmtarg .= ", $fa";
    }
    $out .= "    chiSinkFmt(sink, $fmtstr$fmtarg);\n" if ($fmtstr ne "");
    if ($#{$rest} >= 0) {
        my @arg = @{${$rest}[0]};
        if ($arg[0] eq "arr") {
            my $body = gen_disasm_args("    if ($arg[1]_count) chiSinkPuts(sink, \" |\");\n", $arg[3]);
            $body =~ s/(?!\A)^/    /mg;
            $body =~ s/\n\Z| +$//mg;
            $out .= "    chiSinkPuts(sink, NAME($arg[1])\"[\");\n";
            $out .= "    for (uint32_t $arg[1]_count = 0; $arg[1]_count < $arg[2]; ++$arg[1]_count) $body\n";
            $out .= "    chiSinkPuts(sink, \" ]\");\n";
        } else {
            die;
        }
    }
    $out .= "}\n";
    return $out;
}

sub gen_disasm {
    my @insn = @_;
    my $out = "// $generated_by\n";
    foreach (@insn) {
        my ($id, $opcode, $desc, $args, $body) = @$_;
        $out .= "case OP_$opcode: " . gen_disasm_args("", $args) . "break;\n";
    }
    write_text "disasm.h", $out;
}

sub gen_header {
    my ($first_prim, @insn) = @_;
    my $maxlen = 0;
    my $out = "// $generated_by
#pragma once

#define CBY_FOREACH_OPCODE(OP)";
    foreach (@insn) {
        my ($id, $opcode, $desc, $args, $body) = @$_;
        $out .= " \\\n    OP($opcode)";
        $maxlen = length($opcode) if length($opcode) > $maxlen && $id < $first_prim;
    }
    $out .= "

#define _CBY_OPCODE_ENUM(op) OP_##op,
typedef enum { CBY_FOREACH_OPCODE(_CBY_OPCODE_ENUM) } Opcode;
#undef _CBY_OPCODE_ENUM

enum {
    OPCODE_COUNT = @{[$#insn+1]},
    OPCODE_MAXLEN = $maxlen,
    OPCODE_PRIM = $first_prim
};
";
    write_text "opcodes.h", $out;
}

sub gen_builder_args {
    my($opcode, @args) = @_;
    my @type = ();
    my @vars = ();
    my @constraints = ("Builder m");
    my $val = "  u16 ($opcode :: Word16)\n";
    foreach my $arg (@args) {
        my @arg = @$arg;
        if ($arg[0] =~ /\A[rw]\Z/) {
            push(@type, "Reg");
            push(@vars, $arg[2]);
            $val .= "  u$arg[1] (unReg $arg[2])\n";
        } elsif ($arg[0] eq "u") {
            push(@constraints, "Imm $arg[2]");
            push(@type, $arg[2]);
            push(@vars, $arg[2]);
            $val .= "  u$arg[1] $arg[2]\n";
        } elsif ($arg[0] eq "i") {
            push(@constraints, "Integral $arg[2]");
            push(@type, $arg[2]);
            push(@vars, $arg[2]);
            $val .= "  i$arg[1] $arg[2]\n";
        } elsif ($arg[0] eq "f" && $arg[1] == 32) {
            push(@type, "Float");
            push(@vars, $arg[2]);
            $val .= "  u32 (castFloatToWord32 $arg[2])\n";
        } elsif ($arg[0] eq "f" && $arg[1] == 64) {
            push(@type, "Double");
            push(@vars, $arg[2]);
            $val .= "  u64 (castDoubleToWord64 $arg[2])\n";
        } elsif ($arg[0] eq "fnref") {
            push(@type, "TopName");
            push(@vars, "fnref");
            $val .= "  ref (FnRef fnref)\n";
        } elsif ($arg[0] =~ /\A(strref|bytesref)\Z/) {
            push(@constraints, "ConvertString bref ByteString");
            push(@type, "bref");
            push(@vars, "bref");
            $val .= "  bytesref bref\n";
        } elsif ($arg[0] eq "ffiref") {
            push(@type, "FFI");
            push(@vars, "ffi");
            $val .= "  ref (FFIRef (ffiNameWithoutHeader ffi))\n";
        } elsif ($arg[0] eq "arr") {
            last;
        } else {
            die "Invalid $arg[0]";
        }
    }
    return ("(" . join(", ", @constraints) . ") => " . join(" -> ", @type), join(" ", @vars), $val);
}

sub gen_builder {
    my ($first_prim, @insn) = @_;
    my $out = "-- $generated_by\n\nfirstPrim :: Int\nfirstPrim = $first_prim\n\n";
    foreach (@insn) {
        my ($id, $opcode, $desc, $args, $body) = @$_;
        my ($type, $vars, $val) = gen_builder_args($id, @$args);
        $out .= "insn_$opcode :: $type -> m ()\n"
            . "insn_$opcode $vars = do\n$val\n";
    }
    write_text "builder.hs", $out;
}

sub parse_insn {
    my($defs, $offset) = @_;
    $defs = read_text $defs;
    my @insns = ();
    while ($defs =~ /^\/\/\s*([^\n]+)\n([^\{]+)\{\n(.*?)^\}\n\s*/gsm) {
        my ($desc, $insns, $body) = ($1, $2, $3);
        my @insn = split /\n/, $insns;
        foreach (@insn) {
            /\A(\w+)\s+([^%]*)((?:%n=(\d+))?)/;
            my ($opcode, $args, $nvar, $nval) = ($1, $2, $3, $4);
            my ($rest, @arg) = parse_args($args);
            die $rest if ($rest ne "");

            # $n and $i handling
            my ($thisdesc, $thisbody) = ($desc, $body);
            if ($nvar ne "") {
                $nval = int($nval);
                $thisbody =~ s/%n/$nval/g;
                $thisdesc =~ s/%n/$nval/g;
                my @lines = split /\n/, $thisbody;
                $thisbody = "";
                for my $line (@lines) {
                    if ($line =~ /%i/) {
                        for (my $i = 0; $i < $nval; ++$i) {
                            my $iline = $line;
                            $iline =~ s/%i/$i/g;
                            $thisbody .= "$iline\n";
                        }
                    } else {
                        $thisbody .= "$line\n";
                    }
                }
            }

            # reference other instruction
            if ($thisbody =~ /\s+%goto\s+(\w+);/) {
                my $ref = $1;
                foreach my $other (@insns) {
                    my ($other_id, $other_opcode, $other_desc, $other_args, $other_body) = @$other;
                    if ($other_opcode eq $ref) {
                        $thisbody =~ s/%goto\s+$ref;/{$other_body}/g;
                        last;
                    }
                }
            }

            push @insns, [$#insns+1+$offset, $opcode, $thisdesc, \@arg, $thisbody];
        }
    }
    return @insns;
}

my @insns = parse_insn "insn.defs", 0;
my $first_prim = $#insns + 1;
my @priminsns = parse_insn "priminsn.defs", $first_prim;

my @allinsns = ();
push(@allinsns, @insns, @priminsns);

gen_doc @allinsns;
gen_header $first_prim, @allinsns;
gen_rewrite @allinsns;
gen_disasm @allinsns;
gen_interp @allinsns;
gen_builder $first_prim, @insns;
